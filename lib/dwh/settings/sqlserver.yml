# quotes and string lit
quote: "[@exp]"
string_literal: "'@exp'"

# Date Literal Formats
date_format: "%Y-%m-%d"
date_time_format: "%Y-%m-%d %H:%M:%S"
date_time_tz_format: "%Y-%m-%d %H:%M:%S %Z"
date_type: "string" # alternative is int, integer, dateint
day_name_format: "dddd"
abbreviated_day_name_format: "ddd"
month_name_format: "MMMM"
abbreviated_month_name_format: "MMM"

# Date functions patterns
current_date: "CAST(GETDATE()  DATE)"
current_time: "CAST(GETDATE() AS TIME)"
current_timestamp: "GETDATE()"
truncate_date: "DATETRUNC(@unit, @exp)"
date_add: "DATEADD(@unit, @val, @exp)"
date_diff: "DATEDIFF(DAY, @start_exp, @end_exp)"
date_format_sql: "FORMAT(@exp, '@format')"
date_literal: "'@val'"
date_time_literal: "'@val'"
extract_year: 'YEAR(@exp)'
extract_month: 'MONTH(@exp)'
extract_quarter: 'DATEPART(QUARTER, @exp)'
extract_day_of_year: 'DATEPART(DAYOFYEAR, @exp)'
extract_day_of_month: 'DAY(@exp)'
extract_day_of_week: 'DATEPART(WEEKDAY, @exp)'
extract_week_of_year: 'DATEPART(WEEK, @exp)'
extract_hour: 'DATEPART(HOUR, @exp)'
extract_minute: 'DATEPART(MINUTE, @exp)'
extract_year_month: 'CAST(CONCAT(YEAR(@exp), FORMAT(MONTH(@exp), N''00'')) AS INT)'
default_week_start_day: "sunday"
week_start_day: "monday"
sunday_week_start_day: "CAST(DATEADD(DAY, -(DATEPART(WEEKDAY, @exp) - 1), @exp) AS DATE)"
monday_week_start_day: "CAST(DATEADD(DAY, -(DATEPART(WEEKDAY, @exp) - 2), @exp) AS DATE)"
cast: "CAST(@exp AS @type)"

# string functions
trim: "TRIM(@exp)"
lower_case: "LOWER(@exp)"
upper_case: "UPPER(@exp)"

# null handling
if_null: "COALESCE(@exp, @when_null)"
null_if: "NULLIF(@exp, @target)"
null_if_zero: "NULLIF(@exp, 0)"

# Relevant db capabilities for query gen
supports_array_functions: false 
supports_table_join: true
supports_full_join: true
supports_cross_join: true
supports_sub_queries: true
supports_common_table_expressions: true
supports_temp_tables: true
create_temp_table_template: "CREATE TEMPORARY TABLE @table AS \n@sql"
supports_window_functions: true
extend_ending_date_to_last_hour_of_day: false # druid needs this for inclusive filtering

# array operations
array_in_list: "ANY_MATCH(@exp, x -> x IN (@list)" # list is comma separated
array_exclude_list: "NONE_MATCH(@exp, x -> x IN (@list)" # list is comma separated
array_unnest_join: "CROSS JOIN UNNEST(@exp) @alias"

# joins
cross_join: "CROSS JOIN @relation"

# sql output behavior
temp_table_type: "cte" # options cte, subquery, temp
temp_table_prefix: ""
# Determines how measures across fact universes are combined.
# Default is full join when supported.
final_pass_measure_join_type: "full" # inner left right etc
apply_advanced_filtering_on_array_projections: false # druid needs a having clause or un-nesting
greedy_apply_date_filters: true
cross_universe_measure_filtering_strategy: "both" # both, final, intermediatet

